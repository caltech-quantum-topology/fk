.TH FK 1 "2025" "fkcompute 0.2.16" "User Commands"
.SH NAME
fk \- compute the FK invariant for braids using inversion, ILP reduction, and compiled helper binary
.SH SYNOPSIS
.B fk
.RI [ interactive ]
.br
.B fk simple
.I BRAID DEGREE
.RI [ \-\-symbolic ]
.br
.B fk config
.I CONFIG_FILE
.RI [ CONFIG_FILE... ]
.br
.B fk template create
.RI [ OUTPUT_PATH ]
.RI [ \-\-overwrite ]
.SH DESCRIPTION
.B fk
computes the FK invariant of braids using a combination of inversion assignments, Integer Linear Programming (ILP) reduction, and optimized C++ computation. The program provides four interfaces: an interactive mode with guided prompts, a simple command-line interface for quick computations, a configuration file interface for complex or batch processing, and a template creation tool for generating configuration files.

The FK invariant is a mathematical object used in knot theory to distinguish different types of knots and links. This implementation uses parallel processing and optimization techniques to make the computation efficient for complex braids.

.SH SUBCOMMANDS
.TP
.B interactive
Interactive mode with step-by-step prompts for all parameters. Guides the user through entering the braid, degree, optional thread count, computation name, and output format preferences. This is the default mode when running
.B fk
without any arguments.
.TP
.B simple
Minimal interface with sensible defaults. Computes the FK invariant using quiet mode and default parameters. Best for quick calculations. Optionally supports symbolic output with the \-\-symbolic flag.
.TP
.B config
Loads all parameters from one or more JSON or YAML configuration files. Supports both single computations and batch processing of multiple braids with shared defaults. When multiple config files are provided, they are processed sequentially with progress tracking.
.TP
.B template
Template management commands for creating configuration files.
.RS
.TP
.B create
Creates a blank YAML configuration template with all available options documented. The template includes examples and comments for all parameters, making it easy to customize for specific computations.
.SH ARGUMENTS
.TP
.I BRAID
The braid word as a list of integers. Accepts multiple formats:
.RS
.IP \(bu 2
JSON-style: "[1, -2, -3, 1]"
.IP \(bu 2
Comma-separated: "1,-2,-3,1"
.IP \(bu 2
Space-separated: "1 -2 -3 1"
.RE
.TP
.I DEGREE
Degree of the invariant computation (positive integer).
.TP
.I CONFIG_FILE
Path to JSON or YAML configuration file containing braid, degree, and other parameters. Multiple files can be provided to process them in sequence.
.TP
.I OUTPUT_PATH
Path for the template file to be created (default: fk_config.yaml).
.SH OPTIONS
The following option is available for the
.B simple
subcommand:
.TP
.BR \-\-symbolic ", " \-\-no\-symbolic
Output result as human-readable symbolic polynomial using SymPy (default: disabled). Requires SymPy to be installed.
.PP
The following option is available for the
.B template create
subcommand:
.TP
.BR \-\-overwrite
Overwrite the output file if it already exists. Without this flag, the command will fail if the file exists.
.SH EXAMPLES
.SS Interactive Mode
.nf
# Start interactive mode (default when no arguments)
fk

# Or explicitly
fk interactive

# The program will prompt for:
# - Braid word (supports multiple formats)
# - Degree (positive integer)
# - Number of threads (optional, press Enter for default)
# - Computation name (optional, for file naming)
# - Symbolic output preference (y/n)
.fi
.SS Simple Usage
.nf
# Basic computation with defaults
fk simple "[1, -2, -2, 3]" 3

# With symbolic polynomial output
fk simple "[1, -2, -2, 3]" 3 --symbolic

# Same braid, different input formats
fk simple "1,-2,-2,3" 3
fk simple "1 -2 -2 3" 3
.fi
.SS Template Creation
.nf
# Create a blank template
fk template create

# Create template with custom name
fk template create my_knot.yaml

# Overwrite existing template
fk template create config.yaml --overwrite

# The generated template includes all available options with documentation
.fi
.SS Configuration File
.nf
# Create config using template
fk template create config.yaml
# Edit config.yaml to set your parameters

# Run from config
fk config config.yaml

# Process multiple configuration files
fk config trefoil.yaml figure_eight.yaml hopf_link.json

# Batch processing
cat > batch.yaml << EOF
max_workers: 4
save_data: true
computations:
  - name: trefoil
    braid: [1, 1, 1]
    degree: 2
  - name: figure_eight
    braid: [1, -2, 1, -2]
    degree: 3
EOF

fk config batch.yaml
.fi
.SH CONFIGURATION FILES
Configuration files can be in JSON or YAML format. YAML requires PyYAML to be installed.
Supports both single computations and batch processing.

.SS Single Computation (JSON)
.nf
{
  "braid": [1, -2, -2, 3],
  "degree": 3,
  "max_workers": 4,
  "verbose": true,
  "save_data": true
}
.fi
.SS Batch Processing (YAML)
.nf
# Global defaults applied to all computations
max_workers: 4
save_data: true
verbose: false

computations:
  - name: trefoil
    braid: [1, 1, 1]
    degree: 2

  - name: figure_eight
    braid: [1, -2, -1, 2]
    degree: 3
    max_workers: 8  # Override global workers

  - name: hopf_link
    braid: [1, 1]
    degree: 2
    verbose: true  # Override global verbose setting
.fi

.SS Batch Processing Features
.IP \(bu 2
Global configuration applied to all computations
.IP \(bu 2
Individual computation overrides for any parameter
.IP \(bu 2
Named computations for organized results
.IP \(bu 2
Progress tracking during execution
.IP \(bu 2
Error handling - continues processing if one computation fails
.SH OUTPUT
The program outputs comprehensive computation results as JSON to stdout, including the braid, inversion data, degree, components count, and FK invariant coefficients. When the \-\-symbolic flag is used, human-readable polynomial expressions are shown instead.

.SS Single Computation Output
.nf
{
  "braid": [1, -2, -2, 3],
  "inversion_data": {
    "0": [1, -1, 1],
    "1": [1, 1, -1],
    "2": [-1, 1, 1]
  },
  "degree": 3,
  "components": 4,
  "fk": [
    [[-2, 1], [0, -1], [2, 1]]
  ]
}
.fi

.SS Batch Processing Output
.nf
{
  "trefoil": {
    "braid": [1, 1, 1],
    "inversion_data": {...},
    "degree": 2,
    "fk": {
      "q^-2": 1,
      "q^0": -1,
      "q^2": 1
    }
  },
  "figure_eight": {
    "braid": [1, -2, 1, -2],
    "inversion_data": {...},
    "degree": 3,
    "fk": {
      "q^-1": -1,
      "q^1": -1,
      "q^3": 1
    }
  }
}
.fi

.SS Symbolic Output
When using the \-\-symbolic flag, output appears as human-readable polynomial expressions:
.nf
q - q^3 + x^2*(-q^2 + q^6)
.fi

Variables are chosen based on braid topology:
.IP \(bu 2
1 component: x
.IP \(bu 2
2 components: x, y
.IP \(bu 2
3+ components: a, b, c, d, ... (skipping 'q')

.SS Output Fields
.TP
.B braid
The braid word used in the computation (may be modified during processing)
.TP
.B inversion_data
Dictionary mapping crossing indices to sign assignments from the inversion computation
.TP
.B degree
The degree parameter used for the invariant computation
.TP
.B components
Number of components/strands in the braid topology
.TP
.B fk
FK invariant coefficient matrix as nested lists of [power, coefficient] pairs
.TP
.B symbolic
Human-readable polynomial representation (only present when \-\-symbolic is used)
.SH FILES
.TP
.I data/
Default directory for saved intermediate files when using \-\-save\-data.
.TP
.I *_inversion.json
Saved inversion data files.
.TP
.I *_ilp.csv
Saved ILP problem files.
.SH DEPENDENCIES
.TP
.B Required
Python 3.9+, NumPy, Gurobi (commercial optimization solver), C++ toolchain for compilation
.TP
.B Optional
SymPy 1.10+ (for symbolic polynomial output), PyYAML (for YAML configuration files), Jupyter (for development)
.SH EXIT STATUS
.TP
0
Success
.TP
1
General error (invalid arguments, computation failure, etc.)
.TP
2
File not found (configuration file, binary, etc.)
.SH AUTHORS
Toby, Paul, Lara, Josef, Davide
.SH MATHEMATICA INTEGRATION
The package includes a Wolfram Language (Mathematica) wrapper paclet that provides seamless integration with Mathematica 12.0+. The wrapper supports all core functionality including symbolic computation and configuration file execution.

.PP
Installation in Mathematica:
.nf
PacletInstall[Directory["/path/to/fk-compute/mathematica/FkCompute"]]
Needs["FkCompute"]
.fi

.PP
Usage examples:
.nf
(* Basic computation *)
res = FkCompute[{1, 1, 1}, 2];

(* Symbolic computation *)
res = FkCompute[{1, 1, 1}, 2, "Symbolic" -> True];

(* Configuration file execution *)
res = FkCompute["config.yaml"];
.fi

.PP
The wrapper returns Mathematica Association objects and supports all options available in the Python API, including "Symbolic", "Threads", "Verbose", "MaxWorkers", and "Preset". Error messages are provided for Python execution failures, invalid output, and package errors.

.SH SEE ALSO
.BR python (1),
.BR cmake (1),
.BR gurobi (1),
.BR mathematica (1)

.SH COPYRIGHT
This is free software under the MIT License.
